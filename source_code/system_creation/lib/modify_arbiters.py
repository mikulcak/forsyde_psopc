#!/usr/bin/python

## 
#
# @file
## This script modifies the VHDL system code generated by SOPC Builder.
# It parses the basic system description to find all slave modules that are connected to more than one master module and 
# modifies the SOPC-generated arbitrators to support a TDMA access scheme.
# @copyright BSD New
# @author Marcus Mikulcak
# 
# @param input_xml The basic system description XML file.
# @param input_vhdl The system VHDL file generated by SOPC Builder.

# propagate the functions offered by this module
__all__ = ["modify"]


import fileinput, sys, os

try:
	from lxml import etree as ET
except:
	print "Module lxml not found..."
	sys.exit()

try:
	from blessings import Terminal
except:
	print "Module blessings not found..."
	sys.exit()

t = Terminal()

## this method checks if the file has already been modified
# by checking for the string "grant_shift_delay" which gets inserted by this script
# @todo improve this by adding a small comment section at the beginning of the file
def check_if_already_modified(input_file):
	return_value = False
	input_file_opened = fileinput.input(input_file)
	for line in input_file_opened:
		if "grant_shift_delay" in line:
			return_value = True
	input_file_opened.close()
	return return_value

## This function encapsuales the VHDL snippets that are inserted into the code
# and return them according to the requested type.
#
# The types are 'signals' and 'shift_process' and 'delay_process'
# if the 'signals' snippet is requested, a value has to be provided.
# This value represents the length of the grant_vector (i.e. the number of connected masters)
# if the 'delay_process' snippet is requested, the value represents
# the length of a single TDMA slot in clock cycles
# 
# @param snippet_type the type of snippet.
# @param value The value, according to the snippet type.
# @return A multi-line string containing the snippet with the correct values inserted.

def get_snippet(snippet_type, value=0):
	if snippet_type == "signals":
		snippet = """
					 signal grant_shift_delay : std_logic_vector(31 downto 0) := (others => '0');
					 signal grant_shift_register : std_logic_vector(""" + str(value) + """ downto 0) := (others => '0');"""
	elif snippet_type == "delay_process":
		snippet = """
	process(clk, reset_n)
	begin
	 if reset_n = '0' then
		grant_shift_delay <= (others => '0');
	 elsif clk'event and clk = '1' then
		if (grant_shift_delay = X\"""" + hex(value).lstrip('0x') + """\") then
		  grant_shift_delay <= (others => '0');
		else
		  grant_shift_delay <= grant_shift_delay + 1;
		end if;
	 end if;
	end process;"""
	elif snippet_type == "shift_process":
		snippet = """
	process(clk, reset_n)
	begin
	 if reset_n = '0' then
	 	grant_shift_register(grant_shift_register'left downto grant_shift_register'right+1) <= (others => '0');
		grant_shift_register(grant_shift_register'right) <= '1';
	 elsif clk'event and clk = '1' then
		if (grant_shift_delay = 0) then
		  grant_shift_register <= grant_shift_register(0) & grant_shift_register(grant_shift_register'left downto grant_shift_register'right+1);
		end if;
	 end if;
	end process;"""
	else:
		pass
	return snippet

## This function modifies the global list of slave and master connections used in the main 'modify' function
# for a given slave, it adds it to the list and adds all masters connected to it
#
# @param slave The slave for which the masters have to be identified
# @param slave_list_element The element of the global slave list representing the slave
# @param input_xml_file The basic system description xml file to identify the connections
def get_connected_masters(slave, slave_list_element, input_xml_file):
	try:
		tree = ET.parse(os.path.abspath(input_xml_file))
	except:
		print "The input model could not be read"
		sys.exit()

  # for a given slave, all connections are found (master -> slave)
  # and added to the given list
	input_system_root = tree.getroot()
	for connection in input_system_root.iter('connection'):
		if connection.get('end') == slave:
			if "dma" in connection.get("start"):
				if connection.get("write") == "yes":
					slave_list_element.append(connection.get('start') + "_write_master")
				elif connection.get("read") == "yes":
						slave_list_element.append(connection.get('start') + "_read_master")
			else:
				slave_list_element.append(connection.get('start') + "_data_master")

## This function checks the validity of the TDMA slots set in the input XML
# if more than one master can write in a specific slot, this functions returns False
# 
# @param tdma_slot_list A list of TDMA slots as string.
# @return True, if the list is valid; False, if the list is invalid.
def check_tdma_slots(tdma_slot_list):
	transposed_list =  zip(*tdma_slot_list)
	for list_item in transposed_list:
		 if (''.join(list_item).count('X') > 1):
		 	return False
	return True

## This main function calls all other listed functions and performs the main functionality of the script
#
# @param input_xml_file The basic system description XML file.
# @param system_vhdl_file The SOPC Builder-generated VHDL system file containing all modules and arbitrators and the Avalon interconnect.
def modify(input_xml_file, system_vhdl_file):
	print t.bold("Reading xml input file " + input_xml_file + "...\n")

	# try to parse the xml file and load it into the variable 'tree' (of class ElementTreee)
	try:
		tree = ET.parse(os.path.abspath(input_xml_file))
	except:
		print "The input model could not be read"
		sys.exit()
	
	# find its root (of class Element, which allows all required operations)
	input_system_root = tree.getroot()

	tdma_round_length = 0
	tdma_slot_length = 0

	# create the dictionary to store the number of master connected to each slave
	# e.g.: {'slave1' : '3', 'slave2' : '2'}
	connection_count = {}

	# iterate over all connections in the input system XML
	# if a slave is found, add it to the connection_count dictionary and set the count to 1
	# if a slave is found and is already in the dictionary, increment its connection count
	for connection in input_system_root.iter('connection'):
		if not (connection.get('end') in connection_count.keys()):
			connection_count[connection.get('end')] = 1
		else:
			new_count = int(connection_count[connection.get('end')]) + 1
			connection_count[connection.get('end')] = str(new_count)

	# create the two-dimensional list of slave modules and the master modules connected to them, e.g.:
	# slave1    slave 2
	# master_1  master_1
	# master_2

	# the main loop below iterates over every slave in this list

	slave_modules_to_process = []
	slave_counter = 0

	# this loop iterates over the connection_count dictionary and for every slave,
	# whose connection count is larger than 1
	# then call the get_connected_masters() function to add the names of all masters
	# as the second dimension of the list of slaves and masters

	for slave_key in connection_count.keys():
		if (int(connection_count[slave_key]) > 1):
			if (not ("fifo" in slave_key)) and (not slave_key.startswith("memory_cpu_")):
				connected_masters_list = [slave_key]
				slave_modules_to_process.append(connected_masters_list)
				get_connected_masters(slave_key, slave_modules_to_process[slave_counter], input_xml_file)
				slave_counter = slave_counter + 1

	slot_list = {}

	for slave in slave_modules_to_process:
		for module in input_system_root.iter('module'):
			if module.get("name") == slave[0]:
				slot_list[slave[0]] = {}
				for connected_master in slave[1::]:
					slot_list[slave[0]][connected_master] = module.get(connected_master + "_slots")


	# TDMA checks for each module
	current_slave_slot_list = []

	for current_module in slot_list.keys():
		print t.bold("Reading TDMA attributes for module " + current_module + "...")

		for module in input_system_root.iter('module'):
			if module.get("name") == current_module:
				# get the TDMA attributes from the input XML
				for attribute in module.attrib:
					# the length of a TDMA slot in clock cycles
					if attribute == "tdma_slot_length":
						tdma_slot_length = int(module.get(attribute))

				print t.bold("One TDMA slot is " + str(tdma_slot_length) + " cycles long...")

		for module in input_system_root.iter('module'):
			if module.get("name") == current_module:
				for attribute in module.attrib:
					if attribute.endswith("slots"):
						if tdma_round_length == 0:
							tdma_round_length = len(module.get(attribute))
						else:
							if len(module.get(attribute)) != tdma_round_length:
								print t.color(1)("The TDMA assignment " + attribute + " of " + current_module + " contains the wrong number of slots...")
								sys.exit(1)
						current_slave_slot_list.append(module.get(attribute))


		print t.bold("Checking TDMA round assignments for errors...")
		# for current_connected_master in slot_list[current_module]:
			# print current_connected_master
			# current_slave_slot_list.append(slot_list[current_module][current_connected_master])
		current_slave_slot_list = []
		if check_tdma_slots(current_slave_slot_list) == False:
			sys.exit(t.color(1)("Multiple masters are allowed to write in one TDMA slot for module " + current_module + "..."))

	# end of TDMA checks


	# set the length of the TDMA slots
	delay_in_clock_cycles = tdma_slot_length

	# set the file to be modified
	file_to_process = os.path.abspath(system_vhdl_file)

	# if the file has already been modified, stop script execution to avoid destroying it
	if check_if_already_modified(file_to_process):
		sys.exit(t.color(1)("It seems the file has already been modified."))

	in_current_module = False
	code_added = False

	# print slot_list
	# loop over all slave modules
	for current_module in slot_list.keys():
		print t.bold("\tModifying arbitration code of module " + current_module)
		# open the input file using the fileinput module with the option to directly replace content in the file
		system_code_file = fileinput.input(file_to_process,inplace=1)

		tdma_round_length = len(slot_list[current_module])

		# iterate over every line in the file
		for line in system_code_file:

			# if the line is the begin of the architecture of the current slave, start processing it
			# insert required signals
			# and set the 'in_current_module' flag to trigger more operations that occur inside the architecture
			if ("architecture europa of " + current_module + "_s1_arbitrator") in line:
				print line,
				print "-- begin of inserted code"
				print get_snippet("signals", tdma_round_length - 1)
				print ""
				for connected_master in slot_list[current_module].keys():
					print "\t\t\t\t\tsignal " + connected_master + "_grant_mask : std_logic_vector(" + str(tdma_round_length - 1) + " downto 0) := (others => '0');"
				print ""
				for connected_master in slot_list[current_module].keys():
					print "\t\t\t\t\tsignal " + connected_master + "_granted : std_logic := '0';"

				print "\n-- end of inserted code"
				in_current_module = True
				continue
			if in_current_module == True:
				if line.startswith("begin"):
					print line,
					print "-- begin of inserted code"

					# iterate over the list of master connected to this slave and the input XML
					# to parse the TDMA slots assigned to the masters
					for module in input_system_root.iter('module'):
						for connected_master in slot_list[current_module].keys():
							if connected_master.startswith(module.get('name')):
								print "\t" + connected_master + "_grant_mask <= \"" + slot_list[current_module][connected_master].replace('X', '1').replace('-', '0') + "\";"
					print ""
					# write the single-bit grant signals of each master into the file
					# or_reduce is a zip function using OR on a std_logic_vector which returns a std_logic
					for connected_master in slot_list[current_module].keys():
						print "\t" + connected_master + "_granted <= or_reduce(" + connected_master + "_grant_mask AND grant_shift_register);"

					# insert the delay process with the clock cycles set above
					print get_snippet("delay_process", delay_in_clock_cycles)
					# insert the shift register process
					print get_snippet("shift_process")
					print ""
					# insert the two lines assigning the SOPC-generated grant_vector and chip_select signals to their new version
					# concatenate the grant vector from the single-bit grants
					print '\t' + current_module + "_s1_grant_vector <=",
					counter = 0
					for connected_master in slot_list[current_module].keys():
						if counter == (len(slot_list[current_module].keys()) - 1):
							print connected_master + "_granted;"
						else:
							print connected_master + "_granted &",
						counter = counter + 1

					# the chip_select has to be built using all connected masters
					# it is only high, when a master requests the slave AND when it is granted access to it
					# an OR relation connects these AND pairs for each master
					print '\t' + current_module + "_s1_chipselect <=",
					counter = 0
					for connected_master in slot_list[current_module].keys():
						print "(internal_" + connected_master + "_requests_" + current_module + "_s1 AND internal_" + connected_master + "_granted_" + current_module + "_s1)",
						if counter != (len(slot_list[current_module].keys()) - 1):
							print "OR ",
						if counter == (len(slot_list[current_module].keys()) - 1):
							print ";"
						counter = counter + 1
	
					print "\n-- end of inserted code"
					code_added = True
					continue
				# the original signal assignments of chip_select and grant_vector have to be commented out
				if code_added == True:
					if line.lstrip().startswith(current_module + "_s1_grant_vector"):
						print "-- " + line,      
						continue
					if line.lstrip().startswith(current_module + "_s1_chipselect"):
						print "-- " + line,
						code_added = False
						in_current_module = False            
						continue
			print line,
		# finish operation and close the file
		system_code_file.close()

## If this script is called by itself (and not from within another script where it is imported), this function calls create() with a number of test parameters.
#
def main():
  modify("/home/marcus/Desktop/thesis/branch/jpeg_encoder_final/four_processors/create_quartus_projects/input_files/model_input.xml", "/home/marcus/Desktop/example_applications/jpeg/one_processing_pipeline_four_processors_blabla/one_processing_pipeline_four_processors_blabla_system.vhd")

if __name__ == "__main__":
	main()
